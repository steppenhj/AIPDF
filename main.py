# app.py ‚Äî PDF Í∏∞Î∞ò Q&A (UI Îã®ÏàúÌôî Î≤ÑÏ†Ñ)
import os, re, json, tempfile, hashlib, pathlib
from typing import List, Tuple
from operator import itemgetter

from dotenv import load_dotenv
load_dotenv(override=True)

import streamlit as st
import pandas as pd
import altair as alt

# LangChain / OpenAI
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
try:
    from langchain_community.document_loaders import PyPDFLoader
except ModuleNotFoundError:
    from langchain_community.document_loaders.pdf import PyPDFLoader

from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser, JsonOutputParser
from langchain_core.runnables import RunnablePassthrough
from langchain_core.messages import HumanMessage, AIMessage

from langchain.retrievers import ContextualCompressionRetriever
from langchain.retrievers.document_compressors import LLMChainExtractor

# =========================
# Í∏∞Î≥∏ UI Î∞è ÌéòÏù¥ÏßÄ ÏÑ§Ï†ï
# =========================
st.set_page_config(page_title="PDF Q&A (Simple UI)", page_icon="üìÑ", layout="centered")
st.title("üìÑ PDF Í∏∞Î∞ò AI Q&A")

# =========================
# >>> NEW: ÎÇ¥Î∂Ä ÌëúÏ§Ä ÏÑ§Ï†ïÍ∞í (ÏÇ¨Ïù¥ÎìúÎ∞î Ï†úÍ±∞) <<<
# =========================
# Ïù∏Îç±Ïã± ÏÑ§Ï†ï
CHUNK_SIZE = 1000
CHUNK_OVERLAP = 150
# Í≤ÄÏÉâ/ÏÉùÏÑ± ÏÑ§Ï†ï
TOP_K = 6
FETCH_K = 20
USE_COMPRESSION = True
TEMPERATURE = 0.1
MAX_TOKENS = 1000
# ÎπÑÌåê/Î¶¨Ïä§ÌÅ¨ ÏßàÎ¨∏ Ï≤òÎ¶¨(Ï†ÑÏó≠ Ïä§Ï∫î) ÏÑ§Ï†ï
ENABLE_GLOBAL_CRITIQUE = True
GLOBAL_CRITIQUE_PAGES_CHARS = 700
GLOBAL_CRITIQUE_TOTAL_CHARS = 12000

# =========================
# API ÌÇ§
# =========================
def get_openai_key():
    key = os.getenv("OPENAI_API_KEY")
    if key: return key
    try: return st.secrets["OPENAI_API_KEY"]
    except Exception: return None

OPENAI_API_KEY = get_openai_key()
if not OPENAI_API_KEY:
    st.error("OPENAI_API_KEYÍ∞Ä ÏóÜÏäµÎãàÎã§. (.env ÎòêÎäî .streamlit/secrets.toml / ÌÅ¥ÎùºÏö∞Îìú Secrets ÏÑ§Ï†ï)")
    st.stop()

# ===== Î™®Îç∏ ÏÑ§Ï†ï (ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•) =====
PRIMARY_MODEL = os.getenv("OPENAI_CHAT_MODEL_PRIMARY", "gpt-4o-mini")
LIGHT_MODEL   = os.getenv("OPENAI_CHAT_MODEL_LIGHT",   "gpt-4o-mini")
EMBED_MODEL   = os.getenv("OPENAI_EMBED_MODEL",        "text-embedding-3-small")

# ... (Ïù¥Ï†Ñ ÏΩîÎìúÏùò Ïú†Ìã∏Î¶¨Ìã∞, Ïù∏Îç±Ïã±, LLM Ìó¨Ìçº, ÎãµÎ≥Ä ÏÉùÏÑ±Í∏∞ Ìï®ÏàòÎì§ÏùÄ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ) ...
# =========================
# Ïú†Ìã∏ (ÏùòÎèÑ¬∑Í∞úÏàò ÌååÏã± / ÎπÑÏö©¬∑Ï∫êÏãú)
# =========================
PROS_KEYS = ["ÏûòÎêú", "Ïûò Îêú", "Ïû•Ï†ê", "Í∞ïÏ†ê", "Ï¢ãÏùÄ Ï†ê"]
CONS_KEYS = ["Î∂ÄÏ°±", "Îã®Ï†ê", "ÌïúÍ≥Ñ", "Î¶¨Ïä§ÌÅ¨", "Î¨∏Ï†úÏ†ê", "Ï∑®ÏïΩ", "Î∂àÌé∏", "Ï†úÏïΩ", "ÏúÑÌóò", "Î≥¥ÏôÑ"]
def extract_count(q: str, default=3) -> int:
    m = re.search(r"(\d+)\s*Í∞ÄÏßÄ", q or "")
    return int(m.group(1)) if m else default
def detect_intent(q: str):
    ql = (q or "").lower()
    has_pros = any(k in ql for k in [*PROS_KEYS, "pros", "advantages"])
    has_cons = any(k in ql for k in [*CONS_KEYS, "cons", "risks"])
    if has_pros and has_cons: return "pros_cons"
    if has_cons: return "critique"
    return "general"
def sha256_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()[:16]
def save_dir_for(hash_key: str) -> str:
    base = pathlib.Path(".faiss_cache")
    base.mkdir(parents=True, exist_ok=True)
    return str(base / f"vs_{hash_key}")
def extract_page_citations(text: str) -> List[int]:
    pages = set(int(p) for p in re.findall(r"\[p\.(\d+)\]", text or ""))
    return sorted(list(pages))
def to_text(resp) -> str:
    if resp is None: return ""
    try:
        text = (getattr(resp, "content", None) or "").strip()
        if text: return text
        ak = getattr(resp, "additional_kwargs", {}) or {}
        tcs = ak.get("tool_calls") or []
        if tcs:
            fn = (tcs[0] or {}).get("function", {}); args = fn.get("arguments", "") or ""
            return str(args).strip()
        fc = ak.get("function_call") or {}
        if fc: return str(fc.get("arguments", "") or "").strip()
        return ""
    except Exception: return ""
# =========================
# Ïù∏Îç±Ïä§ ÏÉùÏÑ±/Î°úÎî© (Ï∫êÏãú + ÎîîÏä§ÌÅ¨ Ï†ÄÏû•)
# =========================
@st.cache_resource(show_spinner=False)
def load_or_build_index(pdf_bytes: bytes, chunk_size:int, chunk_overlap:int, api_key:str):
    pdf_hash = sha256_bytes(pdf_bytes)
    folder = save_dir_for(pdf_hash)
    if os.path.isdir(folder) and os.path.exists(os.path.join(folder, "index.faiss")):
        embeddings = OpenAIEmbeddings(api_key=api_key, model=EMBED_MODEL)
        vs = FAISS.load_local(folder, embeddings, allow_dangerous_deserialization=True)
    else:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
            tmp.write(pdf_bytes); path = tmp.name
        docs = PyPDFLoader(path).load()
        splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap, separators=["\n\n", "\n", " ", ""])
        splits = splitter.split_documents(docs)
        embeddings = OpenAIEmbeddings(api_key=api_key, model=EMBED_MODEL)
        vs = FAISS.from_documents(splits, embeddings)
        vs.save_local(folder)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
        tmp.write(pdf_bytes); path2 = tmp.name
    page_docs = PyPDFLoader(path2).load()
    pages = [(d.metadata.get("page", 0)+1, d.page_content) for d in page_docs]
    return vs, pages
def _format_docs(docs, max_chars=4000):
    return "\n\n".join(f"[p.{(d.metadata.get('page',0)+1)}] {d.page_content}" for d in docs)[:max_chars]
# =========================
# LLM Ìò∏Ï∂ú Ìó¨Ìçº
# =========================
def llm_chat(max_tokens:int=600, temperature:float=0.2):
    return ChatOpenAI(api_key=OPENAI_API_KEY, model=PRIMARY_MODEL, temperature=temperature, max_tokens=max_tokens)
def llm_light(max_tokens:int=300, temperature:float=0):
    return ChatOpenAI(api_key=OPENAI_API_KEY, model=LIGHT_MODEL, temperature=temperature, max_tokens=max_tokens)
def llm_chat_json(model=PRIMARY_MODEL, max_tokens=700, temperature=0.1):
    return ChatOpenAI(
        api_key=OPENAI_API_KEY, model=model, temperature=temperature, max_tokens=max_tokens,
        model_kwargs={"response_format": {"type": "json_object"}},
    )
# =========================
# AI ÏßàÎ¨∏ Ï∂îÏ≤ú Í∏∞Îä•
# =========================
@st.cache_data(show_spinner="Î¨∏ÏÑú Î∂ÑÏÑù Î∞è ÏßàÎ¨∏ Ï∂îÏ≤ú Ï§ë...")
def generate_question_suggestions(_pages: List[Tuple[int,str]]) -> List[str]:
    context = "\n".join([f"[p.{p}] {txt[:500]}" for p, txt in _pages[:5]])[:4000]
    sys = (
        "You are an AI assistant that helps users understand complex documents. "
        "Based on the provided context from a document, generate three insightful and distinct questions a user might ask. "
        'Return the result as a valid JSON list of strings. Example: ["Question 1?", "Question 2?", "Question 3?"]'
    )
    user = f"CONTEXT:\n{context}"
    try:
        chain = llm_chat_json(model=LIGHT_MODEL, max_tokens=300) | JsonOutputParser()
        questions = chain.invoke([{"role":"system","content":sys}, {"role":"user","content":user}])
        if isinstance(questions, list) and len(questions) > 0:
            return questions[:3]
    except Exception: pass
    return ["Ïù¥ Î¨∏ÏÑúÏùò ÌïµÏã¨ ÎÇ¥Ïö©ÏùÑ 3Í∞ÄÏßÄÎ°ú ÏöîÏïΩÌï¥Ï§ò", "Ï£ºÏöî Î¶¨Ïä§ÌÅ¨ÎÇò Ïö∞Î†§ÎêòÎäî Ï†êÏùÄ Î¨¥ÏóáÏù¥Ïïº?", "Ïù¥ Î¨∏ÏÑúÍ∞Ä Ï†úÏãúÌïòÎäî Ìñ•ÌõÑ Í≥ÑÌöçÏùÄ Î≠êÏïº?"]
# =========================
# AI ÏãúÍ∞ÅÌôî Í∏∞Îä•
# =========================
def generate_visualization_code(question: str, context: str) -> dict:
    sys = """
You are a data visualization expert. Your task is to generate Altair chart code based on a user's question and a provided text context.
1. First, determine if the question can be answered with a chart using the given context. Look for numerical data, trends, comparisons, or proportions.
2. If visualization is not possible or the data is insufficient, return a JSON object with a single key: `{"error": "No suitable data for visualization."}`.
3. If visualization is possible:
    a. Extract the necessary data and structure it as a JSON list of objects.
    b. Write Python code using the Altair library to create a chart. The code must use a pandas DataFrame named `df` which will be created from the data.
    c. Choose the best chart type (bar, line, pie, area, etc.) to answer the question. Make sure chart labels and titles are in KOREAN.
4. Return a single valid JSON object with two keys: "data" (the extracted data) and "code" (the Altair code string).
"""
    user = f"USER_QUESTION: \"{question}\"\n\nCONTEXT:\n{context}"
    try:
        chain = llm_chat_json(max_tokens=800) | JsonOutputParser()
        result = chain.invoke([{"role":"system","content":sys}, {"role":"user","content":user}])
        return result
    except Exception:
        return {"error": "Failed to generate visualization code."}

def safe_execute_altair_code(code_str: str, data: list):
    if not data or not isinstance(data, list): return None
    try:
        df = pd.DataFrame(data)
        local_scope = {"alt": alt, "pd": pd, "df": df}
        exec(code_str, {}, local_scope)
        chart = local_scope.get("chart")
        if chart and isinstance(chart, alt.TopLevelMixin):
            return chart
        return None
    except Exception: return None
# =========================
# ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
# =========================
if "vs" not in st.session_state: st.session_state.vs = None
if "pages" not in st.session_state: st.session_state.pages = None
if "messages" not in st.session_state: st.session_state.messages = []
if "uploaded_name" not in st.session_state: st.session_state.uploaded_name = None
if "suggested_questions" not in st.session_state: st.session_state.suggested_questions = []

# =========================
# Î©îÏù∏ UI
# =========================
uploaded = st.file_uploader("1. Î∂ÑÏÑùÌï† PDF Î¨∏ÏÑúÎ•º ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî.", type=["pdf"])
use_visualization = st.checkbox("2. ÎãµÎ≥Ä ÏãúÍ∞ÅÌôî Í∏∞Îä• ÏÇ¨Ïö© (Î≤†ÌÉÄ)", value=False, help="ÎãµÎ≥ÄÏóê ÌëúÎÇò ÏàòÏπòÍ∞Ä ÏûàÏùÑ Í≤ΩÏö∞ AIÍ∞Ä Ï∞®Ìä∏Î•º Ìï®Íªò ÏÉùÏÑ±Ìï©ÎãàÎã§.")

if uploaded:
    if st.session_state.uploaded_name != uploaded.name:
        with st.spinner("PDF Î∂ÑÏÑù Î∞è Ïù∏Îç±Ïã± Ï§ë..."):
            vs, pages = load_or_build_index(uploaded.read(), CHUNK_SIZE, CHUNK_OVERLAP, OPENAI_API_KEY)
            st.session_state.vs, st.session_state.pages = vs, pages
            st.session_state.uploaded_name = uploaded.name
            st.session_state.messages = []
            st.session_state.suggested_questions = generate_question_suggestions(pages)
        st.success(f"'{uploaded.name}' Î∂ÑÏÑù ÏôÑÎ£å! ÏïÑÎûò Ï∂îÏ≤ú ÏßàÎ¨∏ÏùÑ ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÏßÅÏ†ë ÏßàÎ¨∏ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.")
else:
    st.session_state.vs, st.session_state.pages, st.session_state.uploaded_name, st.session_state.messages, st.session_state.suggested_questions = None, None, None, [], []

# =========================
# ÎåÄÌôîÌòï Ï≤¥Ïù∏ ÎπåÎçî
# =========================
def build_chain(retriever):
    system = "ÎÑàÎäî ÏóÖÎ°úÎìúÎêú PDFÏóê Í∑ºÍ±∞Ìï¥ ÌïúÍµ≠Ïñ¥Î°ú ÎãµÌïúÎã§. Ïù¥Ï†Ñ ÎåÄÌôî ÎÇ¥Ïö©ÏùÑ Ï∞∏Í≥†ÌïòÏó¨, ÌòÑÏû¨ ÏßàÎ¨∏Ïóê Í∞ÄÏû• Ï†ÅÏ†àÌïú ÎãµÎ≥ÄÏùÑ ÏÉùÏÑ±ÌïúÎã§. Ìï≠ÏÉÅ **ÏÇ¨Ïö©Ïûê ÏßàÎ¨∏Ïùò ÏùòÎèÑÏôÄ Í∞úÏàò ÏöîÍµ¨Î•º Ï†ïÌôïÌûà Îî∞Î•∏Îã§**. Í∞ÄÎä•ÌïòÎ©¥ bulletÏùÑ ÏÇ¨Ïö©ÌïòÍ≥†, Í∞Å ÌïµÏã¨ Ï£ºÏû• ÎÅùÏóê [p.ÌéòÏù¥ÏßÄ] Í∑ºÍ±∞Î•º Î∂ôÏù∏Îã§. Î¨∏ÏÑúÏôÄ Î¨¥Í¥ÄÌïú Ï∂îÏ∏°ÏùÄ Í∏àÏßÄÌïúÎã§."
    prompt = ChatPromptTemplate.from_messages([
        ("system", system + "\n\nCONTEXT:\n{context}"),
        MessagesPlaceholder(variable_name="chat_history"),
        ("human", "{question}")
    ])
    chain = (
        RunnablePassthrough.assign(context=itemgetter("question") | retriever | _format_docs)
        | {"answer": prompt | llm_chat(max_tokens=MAX_TOKENS, temperature=TEMPERATURE) | StrOutputParser(), "context": itemgetter("context")}
    )
    return chain
# =========================
# ÏßàÎ¨∏ Ï≤òÎ¶¨ Î°úÏßÅ Ìï®Ïàò
# =========================
def handle_question(question: str):
    st.session_state.messages.append({"role": "user", "content": question})
    with st.chat_message("assistant"):
        with st.spinner("ÎãµÎ≥Ä ÏÉùÏÑ± Ï§ë..."):
            base_retriever = st.session_state.vs.as_retriever(search_type="mmr", search_kwargs={"k": TOP_K, "fetch_k": FETCH_K})
            retriever = base_retriever
            if USE_COMPRESSION:
                compressor = LLMChainExtractor.from_llm(llm_light(max_tokens=300, temperature=0))
                retriever = ContextualCompressionRetriever(base_retriever=base_retriever, base_compressor=compressor)

            chain = build_chain(retriever)
            chat_history = [HumanMessage(content=msg["content"]) if msg["role"] == "user" else AIMessage(content=msg["content"]) for msg in st.session_state.messages[:-1]]
            result = chain.invoke({"question": question, "chat_history": chat_history})
            answer = result.get("answer", "ÎãµÎ≥ÄÏùÑ ÏÉùÏÑ±ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§.")
            context = result.get("context", "")

            if not (answer or "").strip(): answer = "‚ö†Ô∏è ÏùëÎãµÏù¥ ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§."
            st.write(answer)

            if use_visualization:
                with st.spinner("ÏãúÍ∞ÅÌôî ÏÉùÏÑ± Ï§ë..."):
                    viz_result = generate_visualization_code(question, context)
                    if "error" not in viz_result:
                        chart = safe_execute_altair_code(viz_result.get("code"), viz_result.get("data"))
                        if chart: st.altair_chart(chart, use_container_width=True)
                        else: st.info("Ï∞®Ìä∏Î•º ÏÉùÏÑ±ÌïòÎäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
                    else: st.info(f"ÏãúÍ∞ÅÌôî Ï†ïÎ≥¥: {viz_result['error']}")

            cited_pages = extract_page_citations(answer)
            if cited_pages and st.session_state.pages:
                with st.expander(f"üîé Ïù∏Ïö©Îêú ÌéòÏù¥ÏßÄ Ïä§ÎãàÌé´ Î≥¥Í∏∞ ({len(cited_pages)}Í∞ú)"):
                    page_map = {pg: txt for pg, txt in st.session_state.pages}
                    for pg in cited_pages: st.markdown(f"**[p.{pg}]**\n\n{(page_map.get(pg) or '')[:500]}")
    st.session_state.messages.append({"role": "assistant", "content": answer})

# =========================
# Q&A Î∞è ÎåÄÌôî Í∏∞Î°ù UI
# =========================
if st.session_state.vs:
    st.markdown("---")
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    if st.session_state.suggested_questions and len(st.session_state.messages) == 0:
        st.markdown("##### AI Ï∂îÏ≤ú ÏßàÎ¨∏:")
        cols = st.columns(len(st.session_state.suggested_questions))
        for i, question_prompt in enumerate(st.session_state.suggested_questions):
            with cols[i]:
                if st.button(question_prompt, key=f"suggestion_{i}", use_container_width=True):
                    handle_question(question_prompt)
                    st.rerun()
    
    if user_input := st.chat_input("PDF ÎÇ¥Ïö©Ïóê ÎåÄÌï¥ ÏßàÎ¨∏ÌïòÏÑ∏Ïöî..."):
        handle_question(user_input)
        st.rerun()

else:
    st.info("PDF Î¨∏ÏÑúÎ•º ÏóÖÎ°úÎìúÌïòÎ©¥ AI Î∂ÑÏÑùÏù¥ ÏãúÏûëÎê©ÎãàÎã§.")